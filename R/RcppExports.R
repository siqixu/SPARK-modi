# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

rcpparma_hello_world <- function() {
    .Call(`_SPARK_rcpparma_hello_world`)
}

rcpparma_outerproduct <- function(x) {
    .Call(`_SPARK_rcpparma_outerproduct`, x)
}

rcpparma_innerproduct <- function(x) {
    .Call(`_SPARK_rcpparma_innerproduct`, x)
}

rcpparma_bothproducts <- function(x) {
    .Call(`_SPARK_rcpparma_bothproducts`, x)
}

#' Do inverse of sysmetric matrix 
#' @param Min A sysmetric matrix
#' 
#' @return A list
#' 
#' @export
SysMatEigen <- function(Min) {
    .Call(`_SPARK_SysMatEigen`, Min)
}

#' Do inverse of sparse sysmetric matrix 
#' @param Min A sysmetric matrix
#' @param num_topin The number of top eigen values
#' 
#' @return A list
#' 
#' @export
SparseSysMatEigen <- function(Min, num_topin) {
    .Call(`_SPARK_SparseSysMatEigen`, Min, num_topin)
}

#' Variance component estimation with covariates using Average Information algorithm
#' @param Yin Working vector
#' @param Xin Covariate matrix
#' @param Din Weight for each gene
#' @param tauin Initial value for variance component
#' @param fixtauin Variance component to be optimized
#' @param tolin Tolerance
#' 
#' @return A list
#' 
#' @export
CovariatesAI <- function(Yin, Xin, Din, tauin, fixtauin, tolin) {
    .Call(`_SPARK_CovariatesAI`, Yin, Xin, Din, tauin, fixtauin, tolin)
}

#' Variance component estimation without covariates using Average Information algorithm, float format
#' @param Yin Working vector
#' @param Xin Covariate matrix
#' @param Din Weight for each gene
#' @param tauin Initial value for variance component
#' @param fixtauin Variance component to be optimized
#' @param tolin Tolerance
#' 
#' @return A list
#' 
#' 
#' @export
noCovariatesAI <- function(Yin, Xin, Din, tauin, fixtauin, tolin) {
    .Call(`_SPARK_noCovariatesAI`, Yin, Xin, Din, tauin, fixtauin, tolin)
}

#' Compute the testing quantities without covariates, float format
#' @param yin Working vector
#' @param Pyin The vector P*y
#' @param cov_matin Kernel matrix to be tested
#' @param Din Weight for each gene
#' @param tauin Initial value for variance component
#' 
#' @return A list
#' 
#' 
#' @export
ComputeTestQuantRcpp_nocov <- function(yin, Pyin, cov_matin, Din, tauin) {
    .Call(`_SPARK_ComputeTestQuantRcpp_nocov`, yin, Pyin, cov_matin, Din, tauin)
}

#' Compute the testing quantities with covariates, float format
#' @param yin Working vector
#' @param Pyin The vector P*y
#' @param Xin Covariate matrix, including the intercept
#' @param cov_matin Kernel matrix to be tested
#' @param Din Weight for each gene
#' @param tauin Initial value for variance component
#' 
#' @return A list
#' 
#' 
#' @export
ComputeTestQuantRcpp_cov <- function(yin, Pyin, Xin, cov_matin, Din, tauin) {
    .Call(`_SPARK_ComputeTestQuantRcpp_cov`, yin, Pyin, Xin, cov_matin, Din, tauin)
}

#' Compute the testing quantities for linear mixed model, float format
#' @param yin Working vector
#' @param Pyin The vector P*y
#' @param Xin Covariate matrix, including the intercept
#' @param cov_matin Kernel matrix to be tested
#' @param Din Weight for each gene
#' @param tauin Initial value for variance component
#' 
#' @return A list
#' 
#' 
#' @export
ComputeTestQuantRcpp_Gaussian <- function(yin, Pyin, Xin, cov_matin, Din, tauin) {
    .Call(`_SPARK_ComputeTestQuantRcpp_Gaussian`, yin, Pyin, Xin, cov_matin, Din, tauin)
}

#' Compute the kernel weights using psedu-counts
#' @param Yin Working vector
#' @param num_kernelin The number of kernel matrices,  10
#' @param Phiin The kernel matrices and identity matrix,  10 + 1 
#' 
#' @return A list
#' 
#' @export
ComputeWeightsRcpp <- function(Yin, num_kernelin, Phiin) {
    .Call(`_SPARK_ComputeWeightsRcpp`, Yin, num_kernelin, Phiin)
}

#' Calculate column-wise or row-wise mean
#' @param sp_data A sparse matrix
#' @param rowMeans A boolean value, whether to calculate row-wise mean
#' @return A n x 1 or p x 1 matrix 
#' @export
sp_means_Rcpp <- function(sp_data, rowMeans = FALSE) {
    .Call(`_SPARK_sp_means_Rcpp`, sp_data, rowMeans)
}

#' Calculate column-wise or row-wise sum
#' @param sp_data A sparse matrix
#' @param rowSums A boolean value, whether to calculate row-wise sum
#' @return A n x 1 or p x 1 matrix 
#' @export
sp_sums_Rcpp <- function(sp_data, rowSums = FALSE) {
    .Call(`_SPARK_sp_sums_Rcpp`, sp_data, rowSums)
}

#' Count column-wise or row-wise non-zero elements of sparse matrix
#' @param sp_data A sparse matrix
#' @param rowNZ A boolean value, whether to count row-wise non-zero elements
#' @return A n x 1 or p x 1 matrix 
#' @export
sp_nz_count_Rcpp <- function(sp_data, rowNZ = FALSE) {
    .Call(`_SPARK_sp_nz_count_Rcpp`, sp_data, rowNZ)
}

#' Calculate column-wise or row-wise variance
#' @param sp_data A sparse matrix
#' @param rowVars A boolean value, whether to calculate row-wise variance
#' @return A n x 1 or p x 1 matrix 
#' @export
sp_vars_Rcpp <- function(sp_data, rowVars = FALSE) {
    .Call(`_SPARK_sp_vars_Rcpp`, sp_data, rowVars)
}

#' Compute Euclidean distance matrix by rows
#' @param x A location matrix
ED_cpp <- function(x) {
    .Call(`_SPARK_ED_cpp`, x)
}

